
<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Muziektheater Eccola - Script Board</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAXCAAAAABPbhI9AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfqAgYJOSQZ9swcAAABmUlEQVQoz22ROWhUYRSFv3PflhmzSRDtxDKNhWBrHW1i0EhsBEvBdBbauDQqWNjbpLS1kwguqI2tlUELdewyMYbBJG/5/2sxQ3jBOeXlg7NcDYomAQDP5aItV6xV70+MAN5spQ7Iq24tAO3Nn8Gfr3kVYwghnMUAxOpJBJBww1PC9ePnq0ygyWIqItt8sro+WTh42u9iZFx9mTcCYggh+Oa9WzthJI8YgXhlPWsAHOz33fuNAe7DYIYofOV1WgPCtu88qNJ2F8MJeXn5XV4Dyfbth6XA24BQmCiXP+eBrH/zUZUCagOAQmewtJFo79rT2nR4LBuGa7o/L/SqhTUpGQdIxOlf506/8Ght/wMAF2Gq96GXxAhjAJfj1ezGwpdiPCCXy6qZH4vfh5v+ZyHkWDP7baWfhXEAIIfy6KelP1aOB5Cjau7j4k4HDZsdTA3u7o5L9dz7SwPCoWcZZslQsiQce7u8m2GWJGaGkVKz27Q8deTVxWfN3xCBlJKU6VMz7fJuydfH853CgXTrBKpUHWruwvaz0cnT/B+LNrO6CQyIbAAAAB50RVh0aWNjOmNvcHlyaWdodABHb29nbGUgSW5jLiAyMDE2rAszOAAAABR0RVh0aWNjOmRlc2NyaXB0aW9uAHNSR0K6kHMHAAAAAElFTkSuQmCC" />
  <style>
* { box-sizing: border-box; }
body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

.topbar{
  display:flex; gap:12px; align-items:center; justify-content:space-between;
  padding:12px 14px; border-bottom:1px solid #ddd; position:sticky; top:0; background:#fff;
  flex-wrap: wrap;
}
.brand{ font-weight:700; display:flex; align-items:center; gap:8px; }
.actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.sep{ width:1px; height:26px; background:#ddd; margin:0 6px; }

button, .fileBtn{
  border:1px solid #ccc; background:#fff; padding:8px 10px; border-radius:10px;
  cursor:pointer; font-size:14px;
}
button.primary{ border-color:#333; }
button.danger{ border-color:#c33; color:#c33; }
button.gdocs{ border-color:#4285f4; color:#4285f4; }
button.gdocs:hover:not(:disabled){ background:#4285f4; color:#fff; }
button:disabled{ opacity:.5; cursor:not-allowed; }

.fileBtn{ display:inline-flex; align-items:center; gap:8px; }
.fileBtn input{ display:none; }

.user-info {
  display: flex; align-items: center; gap: 8px;
  font-size: 13px; color: #666;
}
.user-info img {
  width: 24px; height: 24px; border-radius: 50%;
}
.user-info button {
  padding: 4px 8px; font-size: 12px;
}

.sync-status {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 6px;
  background: #e8f5e9;
  color: #2e7d32;
}
.sync-status.saving { background: #fff3e0; color: #ef6c00; }
.sync-status.error { background: #ffebee; color: #c62828; }
.sync-status.offline { background: #eeeeee; color: #666; }

.layout{
  display:grid; grid-template-columns: 1fr 550px;
  min-height: calc(100vh - 58px);
}
@media (max-width: 800px) {
  .layout { grid-template-columns: 1fr; }
}
.board{
  padding:14px;
  display:flex; gap:12px; align-items:flex-start;
  overflow:auto;
}
.act{
  width: 320px; min-width: 320px;
  border:1px solid #ddd; border-radius:14px; background:#fafafa;
  padding:10px;
}
.actHead{
  display:flex; justify-content:space-between; align-items:center; gap:8px;
  margin-bottom:8px;
}
.actTitle{ font-weight:700; }
.actHead button{ padding:6px 8px; border-radius:10px; }

.scenes{ display:flex; flex-direction:column; gap:8px; min-height:40px; }
.scene{
  border:1px solid #ddd; background:#fff; border-radius:12px;
  padding:10px; cursor:pointer;
}
.scene .small{ font-size:12px; opacity:.7; margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.scene.selected{ border-color:#333; }

.editor{
  border-left:1px solid #ddd; background:#fff; padding:14px;
}
.editorHead{ margin-bottom:10px; }
.editorTitle{ font-weight:800; margin-bottom:4px; }
.muted{ opacity:.7; font-size:13px; }

.editorBody label{ display:flex; flex-direction:column; gap:6px; margin-bottom:12px; }
input, textarea{
  border:1px solid #ccc; border-radius:10px; padding:10px; font-size:14px; width:100%;
}
.editorMeta{ display:flex; justify-content:space-between; align-items:center; gap:10px; }

/* Rich text editor */
.preview-container {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 12px;
}
.editor-toolbar {
  display: flex;
  gap: 2px;
  padding: 6px;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-bottom: none;
  border-radius: 10px 10px 0 0;
  flex-wrap: wrap;
}
.editor-toolbar button {
  padding: 4px 8px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  min-width: 28px;
}
.editor-toolbar button:hover {
  background: #e8e8e8;
}
.editor-toolbar button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.toolbar-sep {
  width: 1px;
  background: #ddd;
  margin: 0 4px;
}
.rich-editor {
  border: 1px solid #ccc;
  border-radius: 0 0 10px 10px;
  padding: 10px;
  min-height: 300px;
  max-height: 400px;
  overflow-y: auto;
  background: #fff;
  font-size: 14px;
  line-height: 1.6;
}
.rich-editor:focus {
  outline: none;
  border-color: #4285f4;
}
.rich-editor[contenteditable="false"] {
  background: #f9f9f9;
  color: #999;
}
.rich-editor:empty:before {
  content: attr(placeholder);
  color: #999;
}
.rich-editor h1 {
  font-size: 1.5em;
  margin: 0.5em 0 0.3em 0;
  font-weight: bold;
}
.rich-editor h2 {
  font-size: 1.3em;
  margin: 0.5em 0 0.3em 0;
  font-weight: bold;
}
.rich-editor h3 {
  font-size: 1.1em;
  margin: 0.5em 0 0.3em 0;
  font-weight: bold;
}
.rich-editor p {
  margin: 0.5em 0;
}
.rich-editor ul, .rich-editor ol {
  margin: 0.5em 0;
  padding-left: 1.5em;
}
.rich-editor li {
  margin: 0.2em 0;
}

/* Login screen */
.login-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background: #f5f5f5;
  padding: 20px;
}
.login-box {
  background: #fff;
  padding: 40px;
  border-radius: 16px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  text-align: center;
  max-width: 400px;
}
.login-box h1 { margin: 0 0 10px 0; }
.login-box p { color: #666; margin-bottom: 24px; }
.login-box button {
  background: #4285f4;
  color: #fff;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 0 auto;
}
.login-box button:hover { background: #3367d6; }
.login-box .setup-link {
  margin-top: 20px;
  font-size: 13px;
  color: #666;
}
.login-box .setup-link a {
  color: #4285f4;
  cursor: pointer;
}

/* Modal for setup instructions */
.modal-overlay {
  display: none;
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
  justify-content: center; align-items: center;
}
.modal-overlay.show { display: flex; }
.modal {
  background: #fff; border-radius: 16px; padding: 24px;
  max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;
}
.modal h2 { margin-top: 0; }
.modal code {
  background: #f5f5f5; padding: 2px 6px; border-radius: 4px;
  font-size: 13px;
}
.modal pre {
  background: #f5f5f5; padding: 12px; border-radius: 8px;
  overflow-x: auto; font-size: 13px;
}
.modal ol { padding-left: 20px; }
.modal li { margin-bottom: 8px; }
.modal input {
  width: 100%; margin: 8px 0;
}
.modal .btn-row {
  display: flex; gap: 8px; margin-top: 16px;
}

/* Toast notifications */
.toast {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: #333; color: #fff; padding: 12px 20px; border-radius: 10px;
  z-index: 1001; display: none;
}
.toast.show { display: block; }
.toast.success { background: #2e7d32; }
.toast.error { background: #c62828; }

/* Loading overlay */
.loading-overlay {
  display: none;
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.9);
  z-index: 999;
  justify-content: center; align-items: center;
  flex-direction: column;
  gap: 16px;
}
.loading-overlay.show { display: flex; }
.spinner {
  width: 40px; height: 40px;
  border: 4px solid #ddd;
  border-top-color: #4285f4;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <!-- Login Screen -->
  <div id="loginScreen" class="login-screen">
    <div class="login-box">
      <h1>üé≠ Script Board</h1>
      <p>Log in met Google om het gedeelde script te bewerken.</p>
      <button id="loginBtn">
        <svg width="18" height="18" viewBox="0 0 18 18" fill="none">
          <path d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844a4.14 4.14 0 01-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
          <path d="M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 009 18z" fill="#34A853"/>
          <path d="M3.964 10.71A5.41 5.41 0 013.682 9c0-.593.102-1.17.282-1.71V4.958H.957A8.996 8.996 0 000 9c0 1.452.348 2.827.957 4.042l3.007-2.332z" fill="#FBBC05"/>
          <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 00.957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
        </svg>
        Inloggen met Google
      </button>
      <div class="setup-link">
        Eerste keer? <a id="showSetupLink">Configureer Google Cloud</a>
      </div>
      <div class="setup-link" style="margin-top:10px; font-size:12px; color:#999;">
        Toegang: Ellen, Frits, Eccola
      </div>
    </div>
  </div>

  <!-- Main App (hidden until logged in) -->
  <div id="mainApp" style="display:none;">
    <header class="topbar">
      <div class="brand"><div style="line-height:1.2;"><div>Aladdin en de wonderlamp</div><div style="font-weight:normal; font-size:12px; opacity:0.7;">Muziektheater Eccola</div></div></div>

      <div class="actions">
        <button id="addActBtn">+ Acte</button>
        <button id="addSceneBtn" class="primary" disabled>+ Scene</button>

        <span class="sep"></span>

        <button id="exportDocxBtn">üìÑ Download .docx</button>
        <button id="exportJsonBtn">üíæ Backup ‚Üí Drive</button>
        <button id="importJsonBtn">üìÇ Herstel ‚Üê Drive</button>
        <button id="restoreBackupBtn" title="Herstel van lokale backup">üîÑ Lokaal</button>
        <button id="searchReplaceBtn" title="Zoek en vervang in alle scenes">üîç Zoek/Vervang</button>
        
        <span class="sep"></span>
        
        <span id="syncStatus" class="sync-status">‚úì Opgeslagen</span>
      </div>

      <div id="userInfo" class="user-info">
        <img id="userAvatar" src="" alt="" />
        <span id="userName"></span>
        <button id="signOutBtn">Uitloggen</button>
      </div>
    </header>

    <main class="layout">
      <section class="board" id="board"></section>

      <aside class="editor">
        <div class="editorHead">
          <div class="editorTitle">Editor</div>
          <div id="selectedPath" class="muted">Selecteer een scene‚Ä¶</div>
        </div>

        <div class="editorBody">
          <label>
            Titel
            <input id="sceneTitle" type="text" placeholder="Bijv. Markt in Agrabah" disabled />
          </label>

          <div class="preview-container">
            <div class="editor-toolbar" id="editorToolbar">
              <button type="button" data-cmd="bold" title="Vet (Ctrl+B)"><b>B</b></button>
              <button type="button" data-cmd="italic" title="Cursief (Ctrl+I)"><i>I</i></button>
              <button type="button" data-cmd="underline" title="Onderstrepen (Ctrl+U)"><u>U</u></button>
              <span class="toolbar-sep"></span>
              <button type="button" data-cmd="h1" title="Kop 1">H1</button>
              <button type="button" data-cmd="h2" title="Kop 2">H2</button>
              <button type="button" data-cmd="h3" title="Kop 3">H3</button>
              <span class="toolbar-sep"></span>
              <button type="button" data-cmd="insertUnorderedList" title="Opsomming">‚Ä¢</button>
              <button type="button" data-cmd="insertOrderedList" title="Genummerde lijst">1.</button>
            </div>
            <div class="rich-editor" id="sceneText" contenteditable="false" placeholder="Plak of typ hier de scene-tekst..."></div>
          </div>

          <div class="editorMeta">
            <button id="deleteSceneBtn" class="danger" disabled>Scene verwijderen</button>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Setup Modal -->
  <div id="setupModal" class="modal-overlay">
    <div class="modal">
      <h2>üîß Google Drive Setup</h2>
      <p>Om Script Board te gebruiken, moet je eenmalig een Google Cloud project aanmaken:</p>
      
      <ol>
        <li>Ga naar <a href="https://console.cloud.google.com/apis/credentials" target="_blank">Google Cloud Console</a></li>
        <li>Maak een nieuw project aan (of selecteer een bestaand project)</li>
        <li>Klik op <strong>"+ CREATE CREDENTIALS"</strong> ‚Üí <strong>"OAuth client ID"</strong></li>
        <li>Kies <strong>"Web application"</strong> als type</li>
        <li>Voeg bij <strong>"Authorized JavaScript origins"</strong> toe:
          <pre id="originUrl"></pre>
        </li>
        <li>Klik op <strong>"CREATE"</strong> en kopieer de <strong>Client ID</strong></li>
        <li>Ga naar <strong>"OAuth consent screen"</strong> en configureer:
          <ul>
            <li>User type: <strong>External</strong></li>
            <li>Voeg je eigen e-mail toe als test user</li>
          </ul>
        </li>
        <li>Ga naar <strong>"Enabled APIs"</strong> en activeer <strong>Google Drive API</strong></li>
      </ol>

      <label>
        <strong>Plak hier je Client ID:</strong>
        <input id="clientIdInput" type="text" placeholder="123456789-abc123.apps.googleusercontent.com" />
      </label>

      <div class="btn-row">
        <button id="saveClientIdBtn" class="primary">Opslaan</button>
        <button id="cancelSetupBtn">Annuleren</button>
      </div>
    </div>
  </div>

  <!-- Search & Replace Modal -->
  <div id="searchReplaceModal" class="modal-overlay">
    <div class="modal">
      <h2>üîç Zoek en vervang</h2>
      <p>Vervangt in alle scenes (titels √©n teksten).</p>
      
      <label>
        <strong>Zoek naar:</strong>
        <input id="searchInput" type="text" placeholder="Bijv. Aladdin" />
      </label>

      <label style="margin-top:12px;">
        <strong>Vervang door:</strong>
        <input id="replaceInput" type="text" placeholder="Bijv. Ali" />
      </label>

      <div style="margin-top:12px;">
        <label style="flex-direction:row; align-items:center; gap:8px;">
          <input id="caseSensitive" type="checkbox" style="width:auto;" />
          Hoofdlettergevoelig
        </label>
      </div>

      <div id="searchResults" style="margin-top:12px; font-size:13px; color:#666;"></div>

      <div class="btn-row">
        <button id="doReplaceBtn" class="primary">Vervangen</button>
        <button id="previewReplaceBtn">Voorbeeld</button>
        <button id="cancelSearchBtn">Annuleren</button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
    <div id="loadingText">Laden...</div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script>
// ======= Constants =======
const CLIENT_ID_KEY = "scriptboard:clientId";
const DATA_FILENAME = "scriptboard-data.json";
const SHARED_FILE_ID = "1ImUeFmttGaTMuTzHVFmrSTYuSWednPiH"; // Vaste file ID van Eccola's bestand
const uid = () => Math.random().toString(36).slice(2, 10);

// ======= State =======
let state = { acts: [] };
let dataFileId = null;
let accessToken = null;
let currentUser = null;
let tokenClient = null;
let saveTimeout = null;
let docxVersion = 0;

// ======= DOM Elements =======
const loginScreen = document.getElementById("loginScreen");
const mainApp = document.getElementById("mainApp");
const loginBtn = document.getElementById("loginBtn");
const showSetupLink = document.getElementById("showSetupLink");

const boardEl = document.getElementById("board");
const addActBtn = document.getElementById("addActBtn");
const addSceneBtn = document.getElementById("addSceneBtn");
const exportDocxBtn = document.getElementById("exportDocxBtn");
const exportJsonBtn = document.getElementById("exportJsonBtn");
const importJsonBtn = document.getElementById("importJsonBtn");
const restoreBackupBtn = document.getElementById("restoreBackupBtn");
const searchReplaceBtn = document.getElementById("searchReplaceBtn");
const syncStatus = document.getElementById("syncStatus");

const selectedPathEl = document.getElementById("selectedPath");
const sceneTitleEl = document.getElementById("sceneTitle");
const sceneTextEl = document.getElementById("sceneText");
const deleteSceneBtn = document.getElementById("deleteSceneBtn");
const editorToolbar = document.getElementById("editorToolbar");

const userInfoEl = document.getElementById("userInfo");
const userAvatarEl = document.getElementById("userAvatar");
const userNameEl = document.getElementById("userName");
const signOutBtn = document.getElementById("signOutBtn");

const setupModal = document.getElementById("setupModal");
const originUrlEl = document.getElementById("originUrl");
const clientIdInput = document.getElementById("clientIdInput");
const saveClientIdBtn = document.getElementById("saveClientIdBtn");
const cancelSetupBtn = document.getElementById("cancelSetupBtn");

const loadingOverlay = document.getElementById("loadingOverlay");
const loadingText = document.getElementById("loadingText");

let selected = { actId: null, sceneId: null };

// ======= Toast =======
function showToast(message, type = "") {
  const toast = document.getElementById("toast");
  toast.textContent = message;
  toast.className = "toast show " + type;
  setTimeout(() => toast.classList.remove("show"), 3000);
}

// ======= Rich Text Editor =======
function initToolbar() {
  editorToolbar.querySelectorAll('button').forEach(btn => {
    btn.onmousedown = (e) => {
      e.preventDefault(); // Prevent focus loss
      const cmd = btn.dataset.cmd;
      
      if (cmd === 'h1' || cmd === 'h2' || cmd === 'h3') {
        document.execCommand('formatBlock', false, cmd);
      } else {
        document.execCommand(cmd, false, null);
      }
    };
  });
}

function setToolbarEnabled(enabled) {
  editorToolbar.querySelectorAll('button').forEach(btn => {
    btn.disabled = !enabled;
  });
}

initToolbar();

// Paste handler - behoudt opmaak bij plakken
sceneTextEl.addEventListener("paste", (e) => {
  e.preventDefault();
  
  // Probeer eerst HTML te krijgen (behoud opmaak)
  const html = e.clipboardData.getData("text/html");
  
  if (html) {
    // Clean up de HTML - verwijder onnodige styling maar behoud structuur
    const temp = document.createElement("div");
    temp.innerHTML = html;
    
    // Verwijder scripts en styles
    temp.querySelectorAll("script, style, meta, link").forEach(el => el.remove());
    
    // Verwijder inline styles maar behoud structurele tags
    temp.querySelectorAll("*").forEach(el => {
      el.removeAttribute("style");
      el.removeAttribute("class");
      el.removeAttribute("id");
    });
    
    // Plak de schone HTML
    document.execCommand("insertHTML", false, temp.innerHTML);
  } else {
    // Fallback: plak als platte tekst
    const text = e.clipboardData.getData("text/plain");
    document.execCommand("insertText", false, text);
  }
});

// ======= Loading =======
function showLoading(text = "Laden...") {
  loadingText.textContent = text;
  loadingOverlay.classList.add("show");
}

function hideLoading() {
  loadingOverlay.classList.remove("show");
}

// ======= Sync Status =======
function setSyncStatus(status) {
  syncStatus.className = "sync-status";
  if (status === "saving") {
    syncStatus.textContent = "‚è≥ Opslaan...";
    syncStatus.classList.add("saving");
  } else if (status === "saved") {
    syncStatus.textContent = "‚úì Opgeslagen";
  } else if (status === "error") {
    syncStatus.textContent = "‚ö† Fout";
    syncStatus.classList.add("error");
  } else if (status === "offline") {
    syncStatus.textContent = "Offline";
    syncStatus.classList.add("offline");
  }
}

// ======= Client ID =======
function getClientId() {
  return localStorage.getItem(CLIENT_ID_KEY);
}

function setClientId(id) {
  localStorage.setItem(CLIENT_ID_KEY, id);
}

// ======= Setup Modal =======
function showSetupModal() {
  originUrlEl.textContent = window.location.origin || window.location.protocol + "//" + window.location.host;
  clientIdInput.value = getClientId() || "";
  setupModal.classList.add("show");
}

function hideSetupModal() {
  setupModal.classList.remove("show");
}

showSetupLink.onclick = showSetupModal;
cancelSetupBtn.onclick = hideSetupModal;

saveClientIdBtn.onclick = () => {
  const clientId = clientIdInput.value.trim();
  if (!clientId) {
    alert("Vul een Client ID in");
    return;
  }
  setClientId(clientId);
  hideSetupModal();
  initGoogleAuth();
  showToast("Client ID opgeslagen!", "success");
};

// ======= Google Auth =======
function initGoogleAuth() {
  const clientId = getClientId();
  if (!clientId || typeof google === "undefined") return;

  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: clientId,
    scope: "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/userinfo.profile",
    callback: async (response) => {
      if (response.error) {
        console.error("Auth error:", response);
        showToast("Inloggen mislukt: " + response.error, "error");
        hideLoading();
        return;
      }
      accessToken = response.access_token;
      await onLoginSuccess();
    }
  });
}

loginBtn.onclick = () => {
  const clientId = getClientId();
  if (!clientId) {
    showSetupModal();
    return;
  }

  if (!tokenClient) {
    initGoogleAuth();
  }

  showLoading("Inloggen...");
  tokenClient.requestAccessToken({ prompt: "consent" });
};

signOutBtn.onclick = () => {
  accessToken = null;
  currentUser = null;
  dataFileId = null;
  state = { acts: [] };
  
  loginScreen.style.display = "flex";
  mainApp.style.display = "none";
  
  if (typeof google !== "undefined" && google.accounts && accessToken) {
    google.accounts.oauth2.revoke(accessToken, () => {});
  }
  showToast("Uitgelogd", "success");
};

async function onLoginSuccess() {
  showLoading("Gegevens laden...");
  
  // Fetch user info
  await fetchUserInfo();
  
  // Load data from Drive
  const success = await loadFromDrive();
  
  if (!success) {
    hideLoading();
    return;
  }
  
  // Show main app
  loginScreen.style.display = "none";
  mainApp.style.display = "block";
  
  hideLoading();
  render();
}

async function fetchUserInfo() {
  if (!accessToken) return;

  try {
    const res = await fetch("https://www.googleapis.com/oauth2/v2/userinfo", {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    const user = await res.json();
    currentUser = user;

    userAvatarEl.src = user.picture || "";
    userNameEl.textContent = user.name || user.email || "";
  } catch (e) {
    console.error("Failed to fetch user info:", e);
  }
}

// ======= Google Drive Operations =======
async function findDataFile() {
  // Gebruik altijd het gedeelde bestand van Eccola
  console.log("Gebruik vast bestand ID:", SHARED_FILE_ID);
  return SHARED_FILE_ID;
}

async function loadFromDrive() {
  try {
    // Gebruik altijd het gedeelde bestand
    dataFileId = SHARED_FILE_ID;
    
    // Download file content
    const res = await fetch(
      `https://www.googleapis.com/drive/v3/files/${dataFileId}?alt=media`,
      { headers: { Authorization: `Bearer ${accessToken}` } }
    );
    
    if (!res.ok) {
      throw new Error("Geen toegang tot het bestand. Vraag de eigenaar om het te delen.");
    }
    
    const data = await res.json();
    
    if (data && Array.isArray(data.acts)) {
      state = data;
      docxVersion = data.docxVersion || 0;
    }
    
    setSyncStatus("saved");
    return true;
  } catch (e) {
    console.error("Load error:", e);
    setSyncStatus("error");
    showToast("Fout bij laden: " + e.message, "error");
    alert("Kan het bestand niet laden.\n\nZorg dat het bestand is gedeeld met jouw Google account.");
    return false;
  }
}

async function saveToDrive() {
  if (!accessToken) return;

  setSyncStatus("saving");

  try {
    const content = JSON.stringify({ ...state, docxVersion }, null, 2);
    const blob = new Blob([content], { type: "application/json" });

    // Save to main file
    const response = await fetch(
      `https://www.googleapis.com/upload/drive/v3/files/${dataFileId}?uploadType=media`,
      {
        method: "PATCH",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        },
        body: blob
      }
    );

    if (!response.ok) {
      throw new Error("Opslaan mislukt: " + response.status);
    }

    // Also save local backup in localStorage as fallback
    localStorage.setItem("scriptboard-local-backup", content);
    localStorage.setItem("scriptboard-backup-time", new Date().toISOString());

    setSyncStatus("saved");
    console.log("Opgeslagen om", new Date().toLocaleTimeString());
  } catch (e) {
    console.error("Save error:", e);
    setSyncStatus("error");
    showToast("Opslaan mislukt: " + e.message, "error");
    
    // Save locally as backup when cloud fails
    const content = JSON.stringify({ ...state, docxVersion }, null, 2);
    localStorage.setItem("scriptboard-local-backup", content);
    localStorage.setItem("scriptboard-backup-time", new Date().toISOString());
    showToast("Lokale backup gemaakt", "success");
  }
}

// Debounced save (waits 2 seconds after last change for more reliable saving)
function scheduleSave() {
  if (saveTimeout) clearTimeout(saveTimeout);
  setSyncStatus("saving");
  saveTimeout = setTimeout(() => saveToDrive(), 2000);
}

// Check for local backup on load
function checkLocalBackup() {
  const backup = localStorage.getItem("scriptboard-local-backup");
  const backupTime = localStorage.getItem("scriptboard-backup-time");
  if (backup && backupTime) {
    const time = new Date(backupTime).toLocaleString("nl-NL");
    console.log("Lokale backup gevonden van:", time);
  }
}

// Restore from local backup
function restoreLocalBackup() {
  const backup = localStorage.getItem("scriptboard-local-backup");
  if (backup) {
    try {
      const data = JSON.parse(backup);
      if (data && Array.isArray(data.acts)) {
        state = data;
        docxVersion = data.docxVersion || 0;
        render();
        saveToDrive();
        showToast("Hersteld van lokale backup!", "success");
        return true;
      }
    } catch (e) {
      console.error("Backup restore error:", e);
    }
  }
  return false;
}

// ======= Helpers =======
function findAct(actId) {
  return state.acts.find(a => a.id === actId) || null;
}

function findScene(actId, sceneId) {
  const act = findAct(actId);
  if (!act) return null;
  return act.scenes.find(s => s.id === sceneId) || null;
}

function setSelected(actId, sceneId) {
  selected = { actId, sceneId };
  const scene = actId && sceneId ? findScene(actId, sceneId) : null;
  const act = actId ? findAct(actId) : null;
  const hasSelection = !!scene;

  addSceneBtn.disabled = state.acts.length === 0;
  sceneTitleEl.disabled = !hasSelection;
  sceneTextEl.contentEditable = hasSelection ? "true" : "false";
  deleteSceneBtn.disabled = !hasSelection;
  setToolbarEnabled(hasSelection);

  if (!hasSelection) {
    selectedPathEl.textContent = "Selecteer een scene‚Ä¶";
    sceneTitleEl.value = "";
    sceneTextEl.innerHTML = "";
    render();
    return;
  }

  const sceneIndex = act.scenes.findIndex(s => s.id === sceneId);
  const sceneNumber = sceneIndex + 1;
  const displayTitle = scene.title ? `Scene ${sceneNumber}. ${scene.title}` : `Scene ${sceneNumber}.`;
  
  selectedPathEl.textContent = `${act?.title ?? "Acte"} ‚Üí ${displayTitle}`;
  sceneTitleEl.value = scene.title;
  sceneTextEl.innerHTML = scene.text || "";
  render();
}

// ======= Drag & Drop =======
function rebuildFromDOM() {
  const flat = new Map();
  state.acts.forEach(a => a.scenes.forEach(s => flat.set(s.id, s)));
  const nextActs = state.acts.map(a => ({ ...a, scenes: [] }));

  nextActs.forEach(a => {
    const col = document.getElementById(`scenes-${a.id}`);
    const ids = col ? [...col.querySelectorAll(".scene")].map(el => el.dataset.sceneId) : [];
    a.scenes = ids.map(id => flat.get(id)).filter(Boolean);
  });

  state.acts = nextActs;
  scheduleSave();

  if (selected.sceneId) {
    const newAct = state.acts.find(a => a.scenes.some(s => s.id === selected.sceneId));
    if (newAct) selected.actId = newAct.id;
  }
}

// ======= Render =======
function render() {
  boardEl.innerHTML = "";

  state.acts.forEach(act => {
    const actEl = document.createElement("div");
    actEl.className = "act";
    actEl.dataset.actId = act.id;

    const head = document.createElement("div");
    head.className = "actHead";

    const title = document.createElement("div");
    title.className = "actTitle";
    title.textContent = act.title;

    const headBtns = document.createElement("div");
    headBtns.style.display = "flex";
    headBtns.style.gap = "6px";

    const renameBtn = document.createElement("button");
    renameBtn.textContent = "Hernoem";
    renameBtn.onclick = () => {
      const newTitle = prompt("Nieuwe titel voor acte:", act.title);
      if (newTitle && newTitle.trim()) {
        act.title = newTitle.trim();
        scheduleSave();
        render();
        if (selected.sceneId && selected.actId === act.id) {
          const sc = findScene(selected.actId, selected.sceneId);
          if (sc) {
            const sceneIndex = act.scenes.findIndex(s => s.id === selected.sceneId);
            const sceneNumber = sceneIndex + 1;
            const displayTitle = sc.title ? `Scene ${sceneNumber}. ${sc.title}` : `Scene ${sceneNumber}.`;
            selectedPathEl.textContent = `${act.title} ‚Üí ${displayTitle}`;
          }
        }
      }
    };

    const delBtn = document.createElement("button");
    delBtn.className = "danger";
    delBtn.textContent = "Verwijder";
    delBtn.onclick = () => {
      if (!confirm(`Acte verwijderen: "${act.title}"? (scenes gaan ook weg)`)) return;
      state.acts = state.acts.filter(a => a.id !== act.id);
      if (selected.actId === act.id) setSelected(null, null);
      scheduleSave();
      render();
    };

    headBtns.append(renameBtn, delBtn);
    head.append(title, headBtns);

    const scenesEl = document.createElement("div");
    scenesEl.className = "scenes";
    scenesEl.id = `scenes-${act.id}`;

    act.scenes.forEach((scene, sceneIndex) => {
      const sceneEl = document.createElement("div");
      sceneEl.className = "scene";
      sceneEl.dataset.sceneId = scene.id;

      if (selected.actId === act.id && selected.sceneId === scene.id) {
        sceneEl.classList.add("selected");
      }

      const t = document.createElement("div");
      const sceneNumber = sceneIndex + 1;
      const displayTitle = scene.title ? `Scene ${sceneNumber}. ${scene.title}` : `Scene ${sceneNumber}.`;
      t.textContent = displayTitle;

      const small = document.createElement("div");
      small.className = "small";
      // Strip HTML tags voor preview
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = scene.text || "";
      const plainText = tempDiv.textContent || tempDiv.innerText || "";
      small.textContent = plainText.replace(/\s+/g, " ").trim().slice(0, 90);

      sceneEl.append(t, small);
      sceneEl.onclick = () => setSelected(act.id, scene.id);
      scenesEl.appendChild(sceneEl);
    });

    actEl.append(head, scenesEl);
    boardEl.appendChild(actEl);
  });

  state.acts.forEach(act => {
    const col = document.getElementById(`scenes-${act.id}`);
    if (!col) return;
    if (col._sortable) col._sortable.destroy();

    col._sortable = new Sortable(col, {
      group: "scenes",
      animation: 150,
      onEnd: () => {
        rebuildFromDOM();
        render();
      }
    });
  });

  addSceneBtn.disabled = state.acts.length === 0;
}

// ======= Actions =======
addActBtn.onclick = () => {
  const actId = uid();
  const title = `Acte ${state.acts.length + 1}`;
  state.acts.push({ id: actId, title, scenes: [] });
  scheduleSave();
  selected.actId = actId;
  selected.sceneId = null;
  render();
};

addSceneBtn.onclick = () => {
  if (state.acts.length === 0) return;
  const actId = selected.actId && findAct(selected.actId) ? selected.actId : state.acts[0].id;
  const act = findAct(actId);
  const sceneId = uid();
  const scene = { id: sceneId, title: "", text: "" };
  act.scenes.push(scene);
  scheduleSave();
  render();
  setSelected(actId, sceneId);
};

sceneTitleEl.addEventListener("input", () => {
  const scene = findScene(selected.actId, selected.sceneId);
  if (!scene) return;
  scene.title = sceneTitleEl.value;
  scheduleSave();
  render();
});

sceneTextEl.addEventListener("input", () => {
  const scene = findScene(selected.actId, selected.sceneId);
  if (!scene) return;
  scene.text = sceneTextEl.innerHTML;
  scheduleSave();
  // Don't re-render for text changes (performance)
});

deleteSceneBtn.onclick = () => {
  const act = findAct(selected.actId);
  const scene = findScene(selected.actId, selected.sceneId);
  if (!act || !scene) return;
  if (!confirm(`Scene verwijderen: "${scene.title || 'Zonder titel'}"?`)) return;
  act.scenes = act.scenes.filter(s => s.id !== scene.id);
  scheduleSave();
  setSelected(null, null);
  render();
};

// ======= DOCX Export =======
function parseHtmlForDocx(html, docx) {
  const { Paragraph, TextRun, HeadingLevel } = docx;
  const paragraphs = [];
  
  if (!html || html.trim() === '' || html === '<br>') {
    paragraphs.push(new Paragraph({
      children: [new TextRun({ text: "(Geen tekst)", italics: true, color: "999999", size: 22 })]
    }));
    return paragraphs;
  }
  
  // Create a temporary div to parse HTML
  const temp = document.createElement('div');
  temp.innerHTML = html;
  
  function processNode(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text.trim()) {
        return [new TextRun({ text: text, size: 24 })];
      }
      return [];
    }
    
    if (node.nodeType !== Node.ELEMENT_NODE) return [];
    
    const tag = node.tagName.toLowerCase();
    
    // Headers - zonder HeadingLevel om blauwe kleur te vermijden
    if (tag === 'h1') {
      paragraphs.push(new Paragraph({
        children: [new TextRun({ text: node.textContent, bold: true, size: 32, color: "000000" })],
        spacing: { before: 280, after: 140 }
      }));
      return [];
    }
    if (tag === 'h2') {
      paragraphs.push(new Paragraph({
        children: [new TextRun({ text: node.textContent, bold: true, size: 28, color: "000000" })],
        spacing: { before: 240, after: 120 }
      }));
      return [];
    }
    if (tag === 'h3') {
      paragraphs.push(new Paragraph({
        children: [new TextRun({ text: node.textContent, bold: true, size: 26, color: "000000" })],
        spacing: { before: 200, after: 100 }
      }));
      return [];
    }
    
    // Lists
    if (tag === 'ul' || tag === 'ol') {
      const items = node.querySelectorAll(':scope > li');
      items.forEach((li, i) => {
        const prefix = tag === 'ul' ? '‚Ä¢ ' : `${i + 1}. `;
        paragraphs.push(new Paragraph({
          children: [new TextRun({ text: prefix + li.textContent, size: 24, color: "000000" })],
          spacing: { after: 60 },
          indent: { left: 720 }
        }));
      });
      return [];
    }
    
    // Paragraph or div
    if (tag === 'p' || tag === 'div') {
      const runs = [];
      node.childNodes.forEach(child => {
        runs.push(...processInlineNode(child));
      });
      if (runs.length > 0) {
        paragraphs.push(new Paragraph({
          children: runs,
          spacing: { after: 120 }
        }));
      }
      return [];
    }
    
    // Line break
    if (tag === 'br') {
      return [];
    }
    
    // Process children for other elements
    const runs = [];
    node.childNodes.forEach(child => {
      runs.push(...processNode(child));
    });
    return runs;
  }
  
  function processInlineNode(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text) {
        return [new TextRun({ text: text, size: 24, color: "000000" })];
      }
      return [];
    }
    
    if (node.nodeType !== Node.ELEMENT_NODE) return [];
    
    const tag = node.tagName.toLowerCase();
    const text = node.textContent;
    
    if (tag === 'strong' || tag === 'b') {
      return [new TextRun({ text: text, bold: true, size: 24, color: "000000" })];
    }
    if (tag === 'em' || tag === 'i') {
      return [new TextRun({ text: text, italics: true, size: 24, color: "000000" })];
    }
    if (tag === 'u') {
      return [new TextRun({ text: text, underline: {}, size: 24, color: "000000" })];
    }
    if (tag === 'br') {
      return [new TextRun({ text: '', break: 1 })];
    }
    
    // Default: process children
    const runs = [];
    node.childNodes.forEach(child => {
      runs.push(...processInlineNode(child));
    });
    return runs;
  }
  
  // Process all top-level nodes
  temp.childNodes.forEach(node => {
    const runs = processNode(node);
    if (runs.length > 0) {
      paragraphs.push(new Paragraph({
        children: runs,
        spacing: { after: 120 }
      }));
    }
  });
  
  // If no paragraphs were created, create one from the text content
  if (paragraphs.length === 0 && temp.textContent.trim()) {
    paragraphs.push(new Paragraph({
      children: [new TextRun({ text: temp.textContent, size: 24, color: "000000" })],
      spacing: { after: 120 }
    }));
  }
  
  return paragraphs;
}

async function generateDocxBlob() {
  const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, PageBreak, Footer, PageNumber } = docx;

  const children = [];

  // Titel: Aladdin en de wonderlamp (bold, zwart)
  children.push(new Paragraph({
    children: [new TextRun({ text: "Aladdin en de wonderlamp", bold: true, size: 56, color: "000000" })],
    alignment: AlignmentType.CENTER,
    spacing: { after: 120 }
  }));

  // Subtitel: Muziektheater Eccola (niet bold, zwart)
  children.push(new Paragraph({
    children: [new TextRun({ text: "Muziektheater Eccola", size: 28, color: "000000" })],
    alignment: AlignmentType.CENTER,
    spacing: { after: 400 }
  }));

  const now = new Date().toLocaleDateString("nl-NL", { 
    year: "numeric", month: "long", day: "numeric" 
  });
  children.push(new Paragraph({
    children: [new TextRun({ text: `Ge√´xporteerd op ${now}`, italics: true, size: 22, color: "666666" })],
    alignment: AlignmentType.CENTER,
    spacing: { after: 600 }
  }));

  state.acts.forEach((act, actIndex) => {
    if (actIndex > 0) {
      children.push(new Paragraph({ children: [new PageBreak()] }));
    }

    children.push(new Paragraph({
      children: [new TextRun({ text: act.title, bold: true, size: 36, color: "000000" })],
      spacing: { before: 200, after: 200 }
    }));

    act.scenes.forEach((scene, sceneIndex) => {
      const sceneNumber = sceneIndex + 1;
      const displayTitle = scene.title ? `Scene ${sceneNumber}. ${scene.title}` : `Scene ${sceneNumber}.`;
      
      children.push(new Paragraph({
        children: [new TextRun({ text: displayTitle, bold: true, size: 28, color: "000000" })],
        spacing: { before: 300, after: 100 }
      }));

      // Parse HTML content
      const contentParagraphs = parseHtmlForDocx(scene.text, docx);
      children.push(...contentParagraphs);

      children.push(new Paragraph({ spacing: { after: 200 } }));
    });

    if (act.scenes.length === 0) {
      children.push(new Paragraph({
        children: [new TextRun({ text: "(Geen scenes in deze acte)", italics: true, color: "999999", size: 22 })],
        spacing: { after: 200 }
      }));
    }
  });

  const doc = new Document({
    styles: {
      default: {
        document: {
          run: { font: "Arial", size: 24 }
        }
      }
    },
    sections: [{
      properties: {
        page: {
          size: { width: 11906, height: 16838 },
          margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 }
        }
      },
      footers: {
        default: new Footer({
          children: [
            new Paragraph({
              alignment: AlignmentType.CENTER,
              children: [
                new TextRun({ children: [PageNumber.CURRENT], size: 20 })
              ]
            })
          ]
        })
      },
      children
    }]
  });

  return await Packer.toBlob(doc);
}

exportDocxBtn.onclick = async () => {
  docxVersion++;
  scheduleSave();
  
  const blob = await generateDocxBlob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `ScriptBoard_v${docxVersion}.docx`;
  a.click();
  URL.revokeObjectURL(url);
  
  showToast(`Gedownload als ScriptBoard_v${docxVersion}.docx`, "success");
};

// ======= JSON Backup to Drive / Restore from Drive =======

// Find the parent folder of the data file
async function findBackupFolder() {
  // Get parent folder of the main data file
  const res = await fetch(
    `https://www.googleapis.com/drive/v3/files/${SHARED_FILE_ID}?fields=parents`,
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  const data = await res.json();
  return data.parents ? data.parents[0] : null;
}

exportJsonBtn.onclick = async () => {
  if (!accessToken) {
    showToast("Niet ingelogd", "error");
    return;
  }

  exportJsonBtn.disabled = true;
  exportJsonBtn.textContent = "‚è≥ Opslaan...";

  try {
    const folderId = await findBackupFolder();
    
    const now = new Date();
    const datum = now.toISOString().slice(0, 10);
    const tijd = now.toTimeString().slice(0, 5).replace(":", "-");
    const filename = `scriptboard-backup-${datum}_${tijd}.json`;
    
    const content = JSON.stringify({ ...state, docxVersion }, null, 2);
    const blob = new Blob([content], { type: "application/json" });

    const metadata = {
      name: filename,
      mimeType: "application/json"
    };
    
    // Save in same folder as main file
    if (folderId) {
      metadata.parents = [folderId];
    }

    const form = new FormData();
    form.append("metadata", new Blob([JSON.stringify(metadata)], { type: "application/json" }));
    form.append("file", blob);

    const res = await fetch(
      "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name",
      {
        method: "POST",
        headers: { Authorization: `Bearer ${accessToken}` },
        body: form
      }
    );

    if (!res.ok) throw new Error("Upload mislukt");

    const file = await res.json();
    showToast(`‚úÖ Backup opgeslagen: ${file.name}`, "success");
  } catch (e) {
    console.error("Backup error:", e);
    showToast("Backup mislukt: " + e.message, "error");
  } finally {
    exportJsonBtn.disabled = false;
    exportJsonBtn.textContent = "üíæ Backup ‚Üí Drive";
  }
};

importJsonBtn.onclick = async () => {
  if (!accessToken) {
    showToast("Niet ingelogd", "error");
    return;
  }

  importJsonBtn.disabled = true;
  importJsonBtn.textContent = "‚è≥ Zoeken...";

  try {
    const folderId = await findBackupFolder();
    
    // Search for backup files in the folder, sorted by newest first
    let query = `name contains 'scriptboard-backup' and mimeType='application/json' and trashed=false`;
    if (folderId) {
      query += ` and '${folderId}' in parents`;
    }
    
    const res = await fetch(
      `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&orderBy=createdTime desc&pageSize=10&fields=files(id,name,createdTime)`,
      { headers: { Authorization: `Bearer ${accessToken}` } }
    );
    const data = await res.json();

    if (!data.files || data.files.length === 0) {
      alert("Geen backups gevonden in Google Drive.");
      return;
    }

    // Show list of available backups
    let message = "Beschikbare backups:\n\n";
    data.files.forEach((file, i) => {
      const date = new Date(file.createdTime).toLocaleString("nl-NL");
      message += `${i + 1}. ${file.name} (${date})\n`;
    });
    message += "\nTyp het nummer van de backup die je wilt herstellen:";

    const choice = prompt(message);
    if (!choice) return;

    const index = parseInt(choice) - 1;
    if (isNaN(index) || index < 0 || index >= data.files.length) {
      alert("Ongeldig nummer");
      return;
    }

    const selectedFile = data.files[index];
    
    if (!confirm(`Backup "${selectedFile.name}" herstellen?\n\nDit overschrijft de huidige data.`)) {
      return;
    }

    // Download the selected backup
    importJsonBtn.textContent = "‚è≥ Herstellen...";
    
    const fileRes = await fetch(
      `https://www.googleapis.com/drive/v3/files/${selectedFile.id}?alt=media`,
      { headers: { Authorization: `Bearer ${accessToken}` } }
    );
    const backupData = await fileRes.json();

    if (!backupData || !Array.isArray(backupData.acts)) {
      alert("Ongeldig backup bestand");
      return;
    }

    state = { acts: backupData.acts };
    docxVersion = backupData.docxVersion || 0;

    await saveToDrive();
    setSelected(null, null);
    render();

    showToast(`‚úÖ Hersteld van "${selectedFile.name}"`, "success");
  } catch (e) {
    console.error("Restore error:", e);
    showToast("Herstellen mislukt: " + e.message, "error");
  } finally {
    importJsonBtn.disabled = false;
    importJsonBtn.textContent = "üìÇ Herstel ‚Üê Drive";
  }
};

restoreBackupBtn.onclick = () => {
  const backupTime = localStorage.getItem("scriptboard-backup-time");
  if (!backupTime) {
    alert("Geen lokale backup gevonden.");
    return;
  }
  
  const time = new Date(backupTime).toLocaleString("nl-NL");
  if (confirm(`Lokale backup gevonden van ${time}.\n\nWil je deze herstellen? Dit overschrijft de huidige data.`)) {
    if (restoreLocalBackup()) {
      setSelected(null, null);
    }
  }
};

// ======= Zoek en Vervang =======
const searchReplaceModal = document.getElementById("searchReplaceModal");
const searchInputEl = document.getElementById("searchInput");
const replaceInputEl = document.getElementById("replaceInput");
const caseSensitiveEl = document.getElementById("caseSensitive");
const searchResultsEl = document.getElementById("searchResults");
const doReplaceBtn = document.getElementById("doReplaceBtn");
const previewReplaceBtn = document.getElementById("previewReplaceBtn");
const cancelSearchBtn = document.getElementById("cancelSearchBtn");

searchReplaceBtn.onclick = () => {
  searchInputEl.value = "";
  replaceInputEl.value = "";
  searchResultsEl.innerHTML = "";
  searchReplaceModal.classList.add("show");
  searchInputEl.focus();
};

cancelSearchBtn.onclick = () => {
  searchReplaceModal.classList.remove("show");
};

function countMatches(searchFor, caseSensitive) {
  let total = 0;
  const flags = caseSensitive ? "g" : "gi";
  const regex = new RegExp(searchFor.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
  
  state.acts.forEach(act => {
    act.scenes.forEach(scene => {
      const titleMatches = (scene.title || "").match(regex);
      // Strip HTML for counting text matches
      const temp = document.createElement("div");
      temp.innerHTML = scene.text || "";
      const plainText = temp.textContent || "";
      const textMatches = plainText.match(regex);
      
      total += (titleMatches ? titleMatches.length : 0);
      total += (textMatches ? textMatches.length : 0);
    });
  });
  
  return total;
}

function replaceInHtml(html, searchFor, replaceWith, caseSensitive) {
  // Replace text content without breaking HTML tags
  const flags = caseSensitive ? "g" : "gi";
  const regex = new RegExp(searchFor.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
  
  // Split HTML into tags and text
  const parts = html.split(/(<[^>]+>)/);
  return parts.map(part => {
    // Don't replace inside HTML tags
    if (part.startsWith("<")) return part;
    return part.replace(regex, replaceWith);
  }).join("");
}

previewReplaceBtn.onclick = () => {
  const searchFor = searchInputEl.value;
  if (!searchFor) {
    searchResultsEl.innerHTML = "Vul een zoekterm in.";
    return;
  }
  
  const caseSensitive = caseSensitiveEl.checked;
  const count = countMatches(searchFor, caseSensitive);
  
  if (count === 0) {
    searchResultsEl.innerHTML = `Geen resultaten gevonden voor "<strong>${searchFor}</strong>"`;
  } else {
    searchResultsEl.innerHTML = `<strong>${count}</strong> keer gevonden in alle scenes.`;
  }
};

doReplaceBtn.onclick = () => {
  const searchFor = searchInputEl.value;
  const replaceWith = replaceInputEl.value;
  const caseSensitive = caseSensitiveEl.checked;
  
  if (!searchFor) {
    alert("Vul een zoekterm in.");
    return;
  }
  
  const count = countMatches(searchFor, caseSensitive);
  
  if (count === 0) {
    alert(`Geen resultaten gevonden voor "${searchFor}"`);
    return;
  }
  
  if (!confirm(`${count} keer "${searchFor}" vervangen door "${replaceWith}"?`)) {
    return;
  }
  
  const flags = caseSensitive ? "g" : "gi";
  const regex = new RegExp(searchFor.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
  
  state.acts.forEach(act => {
    act.scenes.forEach(scene => {
      // Replace in title
      scene.title = (scene.title || "").replace(regex, replaceWith);
      // Replace in text (HTML content)
      scene.text = replaceInHtml(scene.text || "", searchFor, replaceWith, caseSensitive);
    });
  });
  
  scheduleSave();
  setSelected(selected.actId, selected.sceneId);
  render();
  
  searchReplaceModal.classList.remove("show");
  showToast(`‚úÖ ${count} keer vervangen`, "success");
};

// ======= Init =======
window.addEventListener("load", () => {
  setTimeout(() => {
    if (getClientId()) {
      initGoogleAuth();
    }
  }, 500);
});
  </script>
</body>
</html>
